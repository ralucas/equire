// Generated by CoffeeScript 1.6.3
(function() {
  var GoogleOauthStrategy, GoogleStrategy, Issue, IssueSchema, Lesson, LessonSchema, MongoURL, User, UserSchema, app, childProcess, client, express, fs, http, io, ip, moment, momentTZ, mongoose, passport, path, routes, server, socketio, sys, timeZone, util, _, _ref, _ref1;

  express = require('express');

  routes = require('./../routes');

  http = require('http');

  path = require('path');

  fs = require('fs');

  util = require('util');

  socketio = require('socket.io');

  mongoose = require('mongoose');

  moment = require('moment');

  passport = require('passport');

  GoogleStrategy = require('passport-google').Strategy;

  GoogleOauthStrategy = require('passport-google-oauth').OAuthStrategy;

  client = require('twilio')('ACe1b7313b5b376f66c4db568dfa97e3e9', '1a3442ad88426e0561ed5d4fd4ae71e1');

  sys = require('sys');

  childProcess = require('child_process');

  _ = require('underscore');

  momentTZ = require('moment-timezone');

  app = express();

  app.set('port', process.env.PORT || 3000);

  app.set('views', __dirname + './../views');

  app.set('view engine', 'jade');

  app.use(express.favicon());

  app.use(express.logger('dev'));

  app.use(express.cookieParser());

  app.use(express.bodyParser());

  app.use(express.methodOverride());

  app.use(express.session({
    secret: 'keyboard cat'
  }));

  app.use(passport.initialize());

  app.use(passport.session());

  app.use(app.router);

  app.use(express["static"](path.join(__dirname, './../public')));

  if ('development' === app.get('env')) {
    app.use(express.errorHandler());
  }

  server = http.createServer(app);

  io = socketio.listen(server);

  io.configure(function() {
    io.set("transports", ["xhr-polling"]);
    return io.set("polling duration", 10);
  });

  MongoURL = (_ref = process.env.MONGOHQ_URL) != null ? _ref : 'mongodb://localhost';

  mongoose.connect(MongoURL);

  moment().format();

  timeZone = 'America/Denver';

  IssueSchema = new mongoose.Schema({
    issue: String,
    username: String,
    displayName: String,
    date: Object,
    timeStamp: Object,
    time: Object,
    totalWait: Number,
    isComplete: Boolean,
    comment: String
  });

  IssueSchema.pre('save', function(next) {
    var htmlEntities, i, index;
    htmlEntities = function(str) {
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    };
    for (index in this) {
      i = this[index];
      if (typeof i === 'string') {
        this[index] = htmlEntities(i);
      }
    }
    return next();
  });

  Issue = mongoose.model('Issue', IssueSchema);

  UserSchema = new mongoose.Schema({
    openId: String,
    displayName: String,
    emails: String,
    isTeacher: Boolean
  });

  User = mongoose.model('User', UserSchema);

  LessonSchema = new mongoose.Schema({
    lesson: String,
    username: String,
    displayName: String,
    date: Object,
    timeStamp: Object,
    time: Object,
    relIssues: Object
  });

  LessonSchema.pre('save', function(next) {
    var htmlEntities, i, index;
    htmlEntities = function(str) {
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    };
    for (index in this) {
      i = this[index];
      if (typeof i === 'string') {
        this[index] = htmlEntities(i);
      }
    }
    return next();
  });

  Lesson = mongoose.model('Lesson', LessonSchema);

  ip = (_ref1 = process.env.IP) != null ? _ref1 : 'http://localhost:3000';

  passport.serializeUser(function(user, done) {
    return done(null, user);
  });

  passport.deserializeUser(function(obj, done) {
    return done(null, obj);
  });

  passport.use(new GoogleStrategy({
    returnURL: ip + '/auth/google/return',
    realm: ip
  }, function(identifier, profile, done) {
    return process.nextTick(function() {
      return User.find({
        emails: profile.emails[0]['value']
      }, function(err, user) {
        if (!user.length) {
          return User.create({
            openId: identifier,
            displayName: profile.displayName,
            emails: profile.emails[0]['value'],
            isTeacher: true
          }, function(err, user) {
            return done(err, user);
          });
        } else {
          return done(err, user[0]);
        }
      });
    });
  }));

  /*
  #Google Oath
  passport.use new GoogleOauthStrategy {
  	clientID: 1011347908775-9mh5kvjs34j8mcssgu0c7k4qqhqpptv5.apps.googleusercontent.com,
  	clientSecret: W7nqydtlJfuOp9m41Ul9hGmy,
  	callbackURL: ip+"/auth/google/callback"
  	},
  	(accesstoken, refreshToken, profile, done) ->
  		process.nextTick () ->
  			User.find {emails: profile.emails[0]['value']}, (err, user) ->
  				if !user.length
  					User.create {
  						openId: identifier,
  						displayName: profile.displayName,
  						emails: profile.emails[0]['value'],
  						isTeacher: true
  					}, (err, user) ->
  						done err, user
  				else
  					done err, user[0]
  */


  app.get('/auth/google', passport.authenticate('google'));

  app.get('/auth/google/return', passport.authenticate('google', {
    session: true,
    successRedirect: '/account',
    failureRedirect: '/'
  }));

  /*
  app.get '/auth/google/callback', passport.authenticate 'google', {
  	session: true,
  	successRedirect: '/account',
  	failureRedirect: '/'}
  */


  io.sockets.on('connection', function(socket) {
    console.log('hello from your socket server');
    socket.on('issueObj', function(issueObj) {
      var current_time, date, issue, timeStamp;
      date = moment().tz(timeZone).format('L');
      timeStamp = moment().tz(timeZone).format('X');
      current_time = moment().tz(timeZone).format('lll');
      issue = new Issue({
        issue: issueObj.newIssue,
        username: issueObj.username,
        displayName: issueObj.displayName,
        date: date,
        timeStamp: timeStamp,
        time: current_time,
        isComplete: false,
        comment: 'None'
      });
      return issue.save(function(err, issue) {
        if (err) {
          return console.log('errror');
        } else {
          console.log('iss', issue);
          /*
          				childProcess.exec('~/linkm/./linkm-tool --on', 
          					(error, stdout, stderr) ->
          						console.log 'stdout: ' + stdout
          						console.log 'stderr: ' + stderr
          						if error isnt null
          							console.log 'exec error: ' + error
          					)
          				setTimeout () ->
          					childProcess.exec('~/linkm/./linkm-tool --off', 
          						(error, stdout, stderr) ->
          							console.log 'stdout: ' + stdout
          							console.log 'stderr: ' + stderr
          							if error isnt null
          								console.log 'exec error: ' + error
          						)
          				, 5000
          */

          client.sendMessage({
            to: '+16145519436',
            from: '+13036256825',
            body: issueObj.displayName + ' ' + issueObj.newIssue + '.'
          }, function(err, responseData) {
            if (!err) {
              console.log(responseData.from);
              return console.log(responseData.body);
            }
          });
          return io.sockets.emit('issue', issue);
        }
      });
    });
    socket.on('issueEditObj', function(issueEditObj) {
      Issue.findByIdAndUpdate(issueEditObj.issueId, {
        issue: issueEditObj.issue
      }, function(err, issue) {
        if (err) {
          return console.log('ERROR!');
        } else {
          return console.log('Edited and Updated!');
        }
      });
      return io.sockets.emit('issueEditObj', issueEditObj);
    });
    socket.on('completeObj', function(completeObj) {
      Issue.findByIdAndUpdate(completeObj.issueId, {
        totalWait: completeObj.totalWait,
        isComplete: completeObj.isComplete,
        comment: completeObj.comment
      }, function(err, issue) {
        if (err) {
          return console.log('ERROR!');
        } else if (completeObj.comment === 'Figured out on own') {
          console.log('figuredoutonown');
          return client.sendMessage({
            to: '+16145519436',
            from: '+13036256825',
            body: issue.displayName + ' ' + completeObj.comment + '.'
          }, function(err, responseData) {
            if (!err) {
              console.log(responseData.from);
              return console.log(responseData.body);
            }
          });
        } else {
          return console.log('Completed and Updated!');
        }
      });
      return io.sockets.emit('completeObj', completeObj);
    });
    socket.on('lessonObj', function(lessonObj) {
      var current_time, date, lesson, timeStamp;
      date = moment().tz(timeZone).format('L');
      timeStamp = moment().tz(timeZone).format('X');
      current_time = moment().tz(timeZone).format('lll');
      lesson = new Lesson({
        lesson: lessonObj.lesson,
        username: lessonObj.username,
        displayName: lessonObj.displayName,
        date: date,
        timeStamp: timeStamp,
        time: current_time
      });
      return lesson.save();
    });
    return socket.on('lessonUpdate', function(lessonUpdate) {
      return Lesson.update({
        date: lessonUpdate.date
      }, {
        lesson: lessonUpdate.lesson
      }, function(err, numberAffected, raw) {
        if (err) {
          console.log('ERROR');
        } else {

        }
        console.log('The number of updated docs was ', numberAffected);
        return console.log('The raw response from Mongo was ', raw);
      });
    });
  });

  /*
  Routing
  */


  app.get('/', function(req, res) {
    return res.render('login');
  });

  app.get('/account', function(req, res) {
    return res.redirect('/student');
  });

  /*
  Student Routing
  */


  app.get('/student', function(req, res) {
    return res.render('student', {
      user: req.user
    });
  });

  app.get('/currentrequests', function(req, res) {
    return res.render('currentrequests', {
      user: req.user
    });
  });

  app.get('/currReq', function(req, res) {
    var currUser;
    currUser = req.user._id;
    return Issue.find({
      username: currUser,
      isComplete: false
    }, function(err, issues) {
      if (err) {
        return console.log('ERROR');
      } else {
        return res.send(issues);
      }
    });
  });

  app.get('/pastrequests', function(req, res) {
    return res.render('pastrequests', {
      user: req.user
    });
  });

  app.get('/pastReq', function(req, res) {
    var currUser;
    currUser = req.user._id;
    return Issue.find({
      username: currUser,
      isComplete: true
    }, function(err, issues) {
      if (err) {
        return console.log('ERROR');
      } else {
        return res.send(issues);
      }
    });
  });

  app.get('/logout', function(req, res) {
    req.logout();
    return res.redirect('/');
  });

  /*
  Teacher Routing
  */


  app.get('/teacher', function(req, res) {
    return res.render('teacher', {
      user: req.user
    });
  });

  app.get('/found', function(req, res) {
    return Issue.find({
      isComplete: false
    }, function(err, issues) {
      if (err) {
        return console.log('ERROR');
      } else {
        return res.send(issues);
      }
    });
  });

  app.get('/reports', function(req, res) {
    return res.render('reports', {
      user: req.user
    });
  });

  app.get('/summary', function(req, res) {
    return res.render('summary', {
      user: req.user
    });
  });

  app.get('/reportsInfo', function(req, res) {
    return Issue.find({}, function(err, issues) {
      if (err) {
        return console.log('ERROR');
      } else {
        return res.send(issues);
      }
    });
  });

  app.get('/lessonInfo', function(req, res) {
    return Lesson.find({}, function(err, lessons) {
      if (err) {
        return console.log('ERROR');
      } else {
        return res.send(lessons);
      }
    });
  });

  app.get('/pieChart', function(req, res) {
    var key;
    key = 'displayName';
    return Issue.find(function(err, issues) {
      var keyCount;
      if (err) {
        return console.log('ERROR');
      } else {
        keyCount = _.countBy(issues, key);
        return res.send(keyCount);
      }
    });
  });

  app.get('/lineChart', function(req, res) {
    var days;
    days = [];
    return Issue.find(function(err, issues) {
      var dates, daysCount, each, _i, _len;
      if (err) {
        return console.log('ERROR');
      } else {
        dates = _.pluck(issues, 'date');
        for (_i = 0, _len = dates.length; _i < _len; _i++) {
          each = dates[_i];
          days.push(moment(each).format('dddd'));
        }
        daysCount = _.countBy(days);
        return res.send(daysCount);
      }
    });
  });

  app.get('/charts', function(req, res) {
    return res.render('charts', {
      user: req.user
    });
  });

  app.get('/builtwith', function(req, res) {
    return res.render('builtwith', {
      user: req.user
    });
  });

  server.listen(app.get('port'), function() {
    return console.log('Express server listening on port ' + app.get('port'));
  });

}).call(this);
